# Agent Hooks

Agent hooks 提供了一种强大的方式来扩展和自定义 agent 在整个执行生命周期中的行为。`BaseAgent` 类暴露了一套全面的 hooks，允许你拦截、修改和响应 agent 执行过程中的各种事件。

## Overview

| Hook | 描述 | 触发时机 |
|------|------|----------|
| [`initialize()`](#initialize) | Agent 初始化设置 | 启动时执行一次 |
| [`onPrepareRequest()`](#onpreparerequest) | 修改系统提示和 Tool | 每次 LLM 请求前 |
| [`onLLMRequest()`](#onllmrequest) | 检查发出的 LLM 请求 | 每次 LLM 调用前 |
| [`onLLMResponse()`](#onllmresponse) | 处理 LLM 响应 | 每次 LLM 调用后 |
| [`onLLMStreamingResponse()`](#onllmstreamingresponse) | 处理流式响应块 | 流式响应期间 |
| [`onEachAgentLoopStart()`](#oneachagentloopstart) | 循环迭代开始 | 每次迭代开始 |
| [`onBeforeToolCall()`](#onbeforetoolcall) | 验证/修改 Tool 参数 | 每次 Tool 执行前 |
| [`onAfterToolCall()`](#onaftertoolcall) | 处理 Tool 结果 | 每次 Tool 执行后 |
| [`onToolCallError()`](#ontooolcallerror) | 处理 Tool 错误 | Tool 执行失败时 |
| [`onProcessToolCalls()`](#onprocesstoolcalls) | 覆盖 Tool 执行 | Tool 批处理前 |
| [`onEachAgentLoopEnd()`](#oneachagentloopend) | 循环迭代结束 | 每次迭代结束 |
| [`onBeforeLoopTermination()`](#onbeforelooptermination) | 控制终止条件 | 循环结束前 |
| [`onAgentLoopEnd()`](#onagentloopend) | 循环完成 | 循环结束时 |
| [`onDispose()`](#ondispose) | 资源清理 | 销毁期间 |

```mermaid
flowchart TD
    A[Agent.run] --> B[initialize]
    B --> C[onEachAgentLoopStart]
    C --> D[onPrepareRequest]
    D --> E[onLLMRequest]
    E --> F[LLM Call]
    F --> G[onLLMResponse/onLLMStreamingResponse]
    G --> H{Tool Calls?}
    H -->|Yes| I[onProcessToolCalls]
    I --> J[onBeforeToolCall]
    J --> K[Tool Execution]
    K --> L{Success?}
    L -->|Yes| M[onAfterToolCall]
    L -->|No| N[onToolCallError]
    M --> O[onEachAgentLoopEnd]
    N --> O
    H -->|No| P[onBeforeLoopTermination]
    P --> Q{Continue?}
    Q -->|Yes| C
    Q -->|No| R[onAgentLoopEnd]
    O --> S{Terminate?}
    S -->|Yes| P
    S -->|No| C
    R --> T[onDispose]
```

## `initialize()`

在 agent 初始化期间调用，用于执行设置操作。

```ts
class CustomAgent extends BaseAgent {
  async initialize(): Promise<void> {
    await this.connectToDatabase();
    await this.loadConfiguration();
    console.log('Agent 初始化成功');
  }
}
```

## `onPrepareRequest()`

在准备 LLM 请求之前调用，允许动态修改系统提示和 Tool。

```ts
class CustomAgent extends BaseAgent {
  onPrepareRequest(context: PrepareRequestContext): PrepareRequestResult {
    let { systemPrompt, tools } = context;
    
    // 根据迭代次数修改系统提示
    if (context.iteration > 3) {
      systemPrompt += '\n\n注意：请专注于提供简洁的最终答案。';
    }
    
    // 根据当前状态过滤 Tool
    const filteredTools = tools.filter(tool => {
      if (context.iteration > 5 && tool.name.includes('search')) {
        return false; // 在后期迭代中禁用昂贵的 Tool
      }
      return true;
    });
    
    return { systemPrompt, tools: filteredTools };
  }
}
```

## `onLLMRequest()`

在向 LLM 发送请求之前触发，允许检查或记录请求。

```ts
class CustomAgent extends BaseAgent {
  async onLLMRequest(id: string, payload: LLMRequestHookPayload): Promise<void> {
    console.log(`向 LLM 发送请求，会话 ${id}`);
    console.log(`模型: ${payload.model}`);
    console.log(`消息数: ${payload.messages.length}`);
    
    // 记录 token 使用情况以进行监控
    this.logTokenUsage(payload);
  }
}
```

## `onLLMResponse()`

在从 LLM 接收响应后触发，允许处理响应。

```ts
class CustomAgent extends BaseAgent {
  async onLLMResponse(id: string, payload: LLMResponseHookPayload): Promise<void> {
    console.log(`收到会话 ${id} 的响应`);
    
    // 跟踪响应指标
    this.trackResponseTime(payload.elapsedMs);
    this.trackTokenUsage(payload.usage);
    
    // 处理被截断的响应
    if (payload.response.choices[0]?.finish_reason === 'length') {
      console.warn('响应因长度限制被截断');
    }
  }
}
```

## `onLLMStreamingResponse()`

为来自 LLM 的流式响应触发。

```ts
class CustomAgent extends BaseAgent {
  onLLMStreamingResponse(id: string, payload: LLMStreamingResponseHookPayload): void {
    // 处理流式块
    console.log(`会话 ${id} 的流式块: ${payload.chunk}`);
    
    // 更新 UI 或发送实时更新
    this.updateStreamingUI(payload.chunk);
  }
}
```

## `onEachAgentLoopStart()`

在每个 agent 循环迭代开始时调用。

```ts
class CustomAgent extends BaseAgent {
  async onEachAgentLoopStart(sessionId: string): Promise<void> {
    console.log(`开始会话 ${sessionId} 的第 ${this.getCurrentLoopIteration()} 次迭代`);
    
    // 注入动态上下文
    this.updateContextForIteration();
    
    // 检查资源限制
    if (this.getCurrentLoopIteration() > this.maxIterations * 0.8) {
      console.warn('接近最大迭代限制');
    }
  }
}
```

## `onBeforeToolCall()`

在执行 Tool 之前调用，允许修改参数或添加验证。

```ts
class CustomAgent extends BaseAgent {
  async onBeforeToolCall(
    id: string,
    toolCall: { toolCallId: string; name: string },
    args: any
  ): Promise<any> {
    console.log(`执行 Tool: ${toolCall.name}`);
    
    // 添加验证
    if (toolCall.name === 'fileOperation' && !this.hasFilePermission()) {
      throw new Error('文件操作权限不足');
    }
    
    // 修改参数
    if (toolCall.name === 'searchWeb') {
      args.maxResults = Math.min(args.maxResults || 10, 5);
    }
    
    return args;
  }
}
```

## `onAfterToolCall()`

在执行 Tool 之后调用，允许修改结果或添加后处理。

```ts
class CustomAgent extends BaseAgent {
  async onAfterToolCall(
    id: string,
    toolCall: { toolCallId: string; name: string },
    result: any
  ): Promise<any> {
    console.log(`Tool ${toolCall.name} 执行完成`);
    
    // 后处理结果
    if (toolCall.name === 'imageAnalysis') {
      result.confidence = this.calculateConfidence(result);
    }
    
    // 记录 Tool 使用情况
    this.logToolUsage(toolCall.name, result);
    
    return result;
  }
}
```

## `onToolCallError()`

当 Tool 执行导致错误时调用，允许处理或转换错误。

```ts
class CustomAgent extends BaseAgent {
  async onToolCallError(
    id: string,
    toolCall: { toolCallId: string; name: string },
    error: any
  ): Promise<any> {
    console.error(`Tool ${toolCall.name} 执行失败:`, error);
    
    // 提供备用响应
    if (toolCall.name === 'weatherAPI') {
      return '天气信息当前不可用，请稍后重试。';
    }
    
    // 转换错误消息
    if (error.code === 'RATE_LIMIT') {
      return '服务暂时繁忙，请稍等片刻后重试。';
    }
    
    return `错误: ${error.message || error}`;
  }
}
```

## `onProcessToolCalls()`

拦截 Tool 调用处理，对测试和模拟至关重要。

```ts
class TestAgent extends BaseAgent {
  onProcessToolCalls(
    id: string,
    toolCalls: ChatCompletionMessageToolCall[]
  ): ToolCallResult[] | undefined {
    // 为测试模拟 Tool 调用
    if (this.isTestMode) {
      return toolCalls.map(call => ({
        toolCallId: call.id,
        content: this.getMockResult(call.function.name),
      }));
    }
    
    // 返回 undefined 进行正常执行
    return undefined;
  }
}
```

## `onEachAgentLoopEnd()`

在每个 agent 循环迭代结束时调用。

```ts
class CustomAgent extends BaseAgent {
  async onEachAgentLoopEnd(context: EachAgentLoopEndContext): Promise<void> {
    console.log(`完成会话 ${context.sessionId} 的第 ${context.iteration} 次迭代`);
    
    // 记录迭代指标
    this.logIterationMetrics(context);
    
    // 检查是否应该继续
    if (this.shouldTerminateEarly(context)) {
      this.requestLoopTermination();
    }
  }
}
```

## `onBeforeLoopTermination()`

在 agent 循环终止之前调用，允许控制终止条件。

```ts
class CustomAgent extends BaseAgent {
  onBeforeLoopTermination(
    id: string,
    finalEvent: AgentEventStream.AssistantMessageEvent
  ): LoopTerminationCheckResult {
    // 确保调用了特定 Tool
    const requiredTools = ['validateResult', 'saveToDatabase'];
    const calledTools = this.getCalledToolsInSession(id);
    
    const allRequiredToolsCalled = requiredTools.every(tool => 
      calledTools.includes(tool)
    );
    
    if (!allRequiredToolsCalled) {
      console.log('未调用必需 Tool，继续循环');
      return { finished: false };
    }
    
    // 检查响应质量
    if (finalEvent.content.length < 50) {
      console.log('响应过短，请求更多详细信息');
      return { finished: false };
    }
    
    return { finished: true };
  }
}
```

## `onAgentLoopEnd()`

当整个 agent 循环完成时调用。

```ts
class CustomAgent extends BaseAgent {
  async onAgentLoopEnd(id: string): Promise<void> {
    console.log(`会话 ${id} 的 agent 循环完成`);
    
    // 清理会话资源
    this.cleanupSession(id);
    
    // 发送完成通知
    await this.notifyCompletion(id);
  }
}
```

## `onDispose()`

在 agent 销毁期间调用，用于清理资源。

```ts
class CustomAgent extends BaseAgent {
  protected async onDispose(): Promise<void> {
    // 清理资源
    await this.closeConnections();
    this.clearTimers();
    console.log('Agent 销毁完成');
  }
}
```
